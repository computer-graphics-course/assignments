###### Практична робота №2
## Рендеринг зображення методом трасування променів

_**Примітка**. Як ви могли б вже запідозрити, ця робота дуже схожа на практичну роботу №5 з першого курсу. Фактично, це вона і є, але в розширеному вигляді та з додатковими акцентами. Якщо ви виконували цей варіант два роки тому, то ви можете використати власні напрацювання, але не забувайте, що важливим аспектом поточного курсу є архітектура, і вам будет потрібно цю програму покращувати та розвивати до кінця семестру_

### Мета роботи
1) Розібратися (або освіжити в пам'яті) загальний принцип рендерингу зображення методом трасування променів;
2) На практиці познайомитись із використанням Dependency Injection у проекті, що розвивається;
3) Використавши напрацювання з попередньої роботи попрактикуватись у розробці модульних програм, до яких змінюються вимоги у процесі їх розвитку.

### Що треба зробити
1. **Графічна частина.** Написати програму, що приймає на вхід файл формату wavefront obj (парсити його можна за допомогою готової бібліотеки), а на виході створює зображення певного формату (того що ви реалізували в попередній роботі) з візуалізацією моделі, яка знаходиться у вхідному файлі.

### Опис методу трасування променів
Метод трасування променів полягає в наступному. Кожна точка або вектор задається трьома координатами. Зазвичай, вектори використовуються замість точок у просторі як вектор між початком координат і точкою. Координати вектора будуть тоді збігатися з координатами точки. Іншими словами точка і вектор — одне й те ж поняттяю. Геометрія, яку треба візуалізувати, задається у вигляді набору трикутників у 3d просторі. Кожен трикутник — це набір з трьох точок/векторів у просторі. Камера, що "знімає" сцену, задається точкою в просторі та вектором напряму зйомки. Камера абсолютно уявна, це лише спосіб зручно називати точку, з якої братимуть початок промені під час трасування. Перед нею на невеликій відстані розташований уявний екран, що розділений на пікселі, кожен з якиї відповідає пікселю у вихідному зображенні. Пікселі на екрані — це також лише точки в просторі, екраном він названий лише для зручності. Із камери в бік сцени запускаються промені, кожен з яких проходить через піксель на уявному екрані. Для кожного з цих променів програма обчислює, чи перетинає він будь-який з трикутників, що розташовані на сцені. Якщо таких трикутників немає, то піксель фарбується в колір фону (чорний, наприклад). В інакшому випадку піксель фарбується іншим кольором. В найпростішому випадку — будь-яким відмінним від кольору фону. При цьому можуть враховуватися колір об\'єкта, кут падіння променя, затінення, глобальне освітлення і т.д. В цьому варіанті ви можете використати [flat shading](https://en.wikipedia.org/wiki/Shading#Flat_shading) або будь-яку складнішу модель затінення.
<img src="https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/lightingnoshadow.gif" width="250"><img src="https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/pixelrender.gif" width="250">

*Зображення взяті з сайту www.scratchapixel.com*

Оскільки кількість трикутників може бути значною (зазвичай набагато більше за 1 млн), а швидкість найпростішого алгоритму складає O(n*m), де n — кількість трикутників, а m — кількість пікселів зображення, використовують структури даних схожі на дерева, що дозволяють швидко відсікати трикутники, які точно не перетинаються з променем під час трасування.

В даному варіанті ви *маєте* використати структуру octree (або KD-tree чи R-tree, що складніше) для оптимізації швидкості роботи трасування, інакше зображення буде генеруватися хвилин 5 і більше. Почніть із простого варіанту і переходьте до складнішого, коли все працюватиме. Наприклад, спочатку на сцені можна показувати лише кулю, перетин променя з якою дуже легко обчислити. Якщо промінь перетинається з кулею, фарбуйте піксель у червоний, якщо ні — в білий. На виході має вийти прапор Японії. Зверніть увагу на пропорції, щоб на цьому кроці не вийшов еліпс. Далі можна спробувати додати один трикутник і алгоритм Моллера-Трумбора, який є на вікі разом із кодом. Лише після цього варто завантажувати obj-файли. І лише насамкінець слід залишити дерево, коли стане зрозуміло, що програма працює і без нього, але дуже довго.


Приклад виклику програми:
```
> Converter.exe --source=example.bmp --goal-format=png
```

Крім того, програма має обробляти ситуацію спроби відкриття некоректного файлу (файлу з іншим розширенням або з некоректним вмістом) і не завершувати роботу аварійно, а виводити повідомленя про помилку. Наприклад: `Error: you are trying to open .tiff file, but only .bmp and . gif files are supported`, або `Error: you trying to open 8bit BMP file, but only BMP32 is supported`

Для заліку роботи потрібно реалізувати щойнайменше два формати файлів (на вибір) - різні формати мають різну складність і тому оцінюються в різну кількість балів. Варіанти форматів:
1. **PPM (portable pixmap format)** - найпростіший текстовий формат для зберігання зображення. Файл містить в собі заголовок, що складається з формату, ширини та довжини зображення в пікселях та максимального значення кожної кольорової компоненти _M_. Після цього у файлі знаходяться трійки значень RGB у діапазоні [0, _M_] для кожного пікселя зображення. Приклад файлу:
```
P3
# Image with width 3 and height 2,
# using 0 or 1 per color (red, green, blue)
3 2 1
1 0 0   0 1 0   0 0 1
1 1 0   1 1 1   0 0 0
```
Формат використовується переважно як допоміжний або проміжний при роботі з іншими типами файлів, детальніше можна почитати у [вікі](https://en.wikipedia.org/wiki/Netpbm#File_formats) або безпосередньо у [специфікації формату](http://netpbm.sourceforge.net/doc/ppm.html)

2. **BMP (bitmap image file)** - простий та дуже розповсюджений формат, має багато варіацій збереження файлів (різна кількість байт на піксель, можливість стискання тощо). Більш детально можна почитати в [описі роботи для першого курсу](https://github.com/ProgramEngineeringKPI/Introduction-To-Programming/blob/master/labs_spring_2020/assignment_4.md), там же можна знайти багато посилань на опис формату. В цьому варіанті треба обрати іншу глибину кольору ніж у роботі для першого курсу (НЕ 24 біти, а, наприклад, 16 або 32)
3. **GIF (Graphics Interchange Format)** - популярний на зарі розвитку інтернету формат, підтримує анімації, має менший  розмір ніж BMP за рахунок використання стискання [Lempel-Ziv](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch). На сьогодні використовується переважно для анімованих [приколів та мемасів](https://giphy.com/). Детальніше - [хабр](https://habr.com/ru/post/127083/), [вікі](https://en.wikipedia.org/wiki/GIF), [детальна структура](https://www.fileformat.info/format/gif/egff.htm)
4. **PNG (Portable Network Graphics)** - алгоритм, що поступово витіснив GIF у вебі за рахунок більших можливостей у передачі кольорів, прозорості та кращому (у більшості випадків) стисненню змісту. Детальніше можна почитати на [хабрі](https://habr.com/ru/post/130472/), у [вікі](https://en.wikipedia.org/wiki/Portable_Network_Graphics) та на [домашньому сайті формату](http://www.libpng.org/pub/png/)(і таке буває)
5. **JPEG (Joint Photographic Experts Group)** - широко розповсюджений, але і найскладніший (використовує один із видів дискретного перетворення Фур'є) із запропонованих варіант. Специфіка алгоритму з втратами призводить до появи видимих артефактів у місцях різкого перехода кольору, тому найбільше використовується для зображень де такі переходи малопомітні або їх немає - наприклад, цифрові фотографії. Детальніше - [хабр](https://habr.com/ru/post/102521/), [ще хабр](https://habr.com/ru/post/206264/), [стаття](https://www.freecodecamp.org/news/how-jpg-works-a4dbd2316f35/), [ще стаття](https://arjunsreedharan.org/post/146070390717/jpeg-101-how-does-jpeg-work#:~:text=JPEG%20is%20a%20lossy%20compression,we%20do%20brightness%20(luminance).), [кодування Хафмана](https://www.impulseadventure.com/photo/jpeg-huffman-coding.html), [вікі](https://en.wikipedia.org/wiki/JPEG)


Крім власне роботи з форматами, коректна програма має бути побудована за принципом плагінів: високорівневий код перетворення файлів не має оперувати конкретними реалізаціями форматів, а тільки абстракціями. Іншими словами, не дозволяється прямого використання `using` або `import` модулів конкретних форматів в програмі-конверторі більше ніж в одному місці (фабриці). 

Приклад можливої структури класів у ООП-мові:

![](./res/scheme_uml_1.png)

В даному випадку програма на високоу рівні оперує інтерфейсами `IImageReader` та `IImageWriter`, не знаючи які саме формати в данний момент підтримуються. Підключення формату-плагіна можливо через рефлексію (наприклад, використання атрибутів у C#/анотацій в Java), або через об'єкт фабрику, який єдиний буде знати про всі поточні формати. В залежності від обраної мови програмування вам доведеться самостійно обрати механізм реалізації підключення плагінів

### Примітки
- В наступних роботах ми будемо використовувати зображення різних інших, більш складних форматів, і тому будемо користуватися готовими бібліотеками. В цій роботі читання\запис файлів різних форматів потрібно реалізувати самостійно (крім алгоритмів стисненния у PNG та GIF).
- Для того щоб здати роботу потрібно зібрати реліз програми під win64 платформу та прикріпити у релізи у вашому гітхаб-репозиторії. Після цього потрібно оновити інформацію для своєї команди в [таблиці (вільний доступ)](https://docs.google.com/spreadsheets/d/1SvkJxrngMhUiRzwHw9N4DJ7HDHBRt_0DSU9-smrAaIk/edit?usp=sharing) та чекати результатів перевірки роботи.


### Оцінювання:
Максимум за роботу можна отримати _16 балів_. Мінімальний "набір" балів (9) можна отримати за роботу "гарний код + bmp + ppm". Якщо ваша ціль за підсумками семестру - Е, можете сміливо брати такий варіант. PNG\GIF трохи складніші та дозволяють отримати більше балів, ну those-who-dare варіант з JPEG дозволяє отримати бали з запасом.
- Якість написання коду - _3 бали_. Якщо ви здаєте роботу вчасно і отримуєте не максимум з цього пункту, ви можете доробити\порефакторити роботу і підвищити оцінку;
- Алгоритм PPM - _3 бали_;
- Алгоритм BMP - _3 балів_;
- Алгоритм PNG та GIF (з використанням бібліотеки для стиснення) - _4 бали_ . Додатково _+1 бал_ за самостоійну реалізацію
- Алгоритм JPEG - _8 балів_;

