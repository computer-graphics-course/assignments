###### Практична робота №2
## Рендеринг зображення методом трасування променів

_**Примітка**. Як ви могли б вже запідозрити, ця робота дуже схожа на практичну роботу №5 з першого курсу. Фактично, це вона і є, але в розширеному вигляді та з додатковими акцентами. Якщо ви виконували цей варіант два роки тому, то ви можете використати власні напрацювання, але не забувайте, що важливим аспектом поточного курсу є архітектура, і вам будет потрібно цю програму покращувати та розвивати до кінця семестру_

### Мета роботи
1) Розібратися (або освіжити в пам'яті) загальний принцип рендерингу зображення методом трасування променів;
2) Так самом згадати\вивчити структуру даних "дерево" та її користь у обробці просторових даних;
3) На практиці познайомитись із використанням Dependency Injection у проекті, що розвивається;
4) Використавши напрацювання з попередньої роботи попрактикуватись у розробці модульних програм, до яких змінюються вимоги у процесі їх розвитку.

### Що треба зробити
1. **Графічна частина.** Написати програму, що приймає на вхід файл формату wavefront obj (парсити його можна за допомогою готової бібліотеки), а на виході створює зображення певного формату (того що ви реалізували в попередній роботі) з візуалізацією моделі, яка знаходиться у вхідному файлі.

### Опис методу трасування променів
Метод трасування променів полягає в наступному:
Кожна точка або вектор задається трьома координатами. Зазвичай, вектори використовуються замість точок у просторі як вектор між початком координат і точкою (координати вектора будуть тоді збігатися з координатами точки), тобто точка і вектор — одне й те ж поняттяю. Геометрія, яку треба візуалізувати, задається у вигляді набору трикутників у 3d просторі. Кожен трикутник — це набір з трьох точок/векторів у просторі. Камера, що "знімає" сцену, задається точкою в просторі та вектором напряму зйомки. Камера абсолютно уявна, це лише спосіб зручно називати точку, з якої братимуть початок промені під час трасування. Перед нею на невеликій відстані розташований уявний екран, що розділений на пікселі, кожен з якиї відповідає пікселю у вихідному зображенні. Пікселі на екрані — це також лише точки в просторі, екраном він названий лише для зручності. Із камери в бік сцени запускаються промені, кожен з яких проходить через піксель на уявному екрані. Для кожного з цих променів програма обчислює, чи перетинає він будь-який з трикутників, що розташовані на сцені. Якщо таких трикутників немає, то піксель фарбується в колір фону (чорний, наприклад). В інакшому випадку піксель фарбується іншим кольором. В найпростішому випадку — будь-яким відмінним від кольору фону. При цьому можуть враховуватися колір об\'єкта, кут падіння променя, затінення, глобальне освітлення і т.д. Для цієї роботи достатньо використати [flat shading](https://en.wikipedia.org/wiki/Shading#Flat_shading).
<img src="https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/lightingnoshadow.gif" width="250"><img src="https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/pixelrender.gif" width="250">

*Зображення взяті з сайту www.scratchapixel.com*

Оскільки кількість трикутників може бути значною (зазвичай набагато більше за 1 млн), а швидкість найпростішого алгоритму складає O(n*m), де n — кількість трикутників, а m — кількість пікселів зображення, використовують структури даних схожі на дерева, що дозволяють швидко відсікати трикутники, які точно не перетинаються з променем під час трасування.

В цій роботі ви *маєте* використати структуру [octree](https://en.wikipedia.org/wiki/Octree#:~:text=An%20octree%20is%20a%20tree,three%2Ddimensional%20analog%20of%20quadtrees.) (або [KD-tree](https://en.wikipedia.org/wiki/K-d_tree) чи [R-tree](https://en.wikipedia.org/wiki/R-tree), що складніше) для оптимізації швидкості роботи трасування, інакше зображення буде генеруватися хвилин 5 і більше. Почніть із простого варіанту і переходьте до складнішого, коли все працюватиме. Наприклад: спочатку на сцені можна показувати лише кулю, перетин променя з якою дуже легко обчислити. Якщо промінь перетинається з кулею, фарбуйте піксель у червоний, якщо ні — в білий. На виході має вийти прапор Японії. Зверніть увагу на пропорції, щоб на цьому кроці не вийшов еліпс. Далі можна спробувати додати один трикутник і алгоритм Моллера-Трумбора, який є на [вікі](https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm) разом із кодом. Лише після цього варто завантажувати obj-файли. І лише насамкінець слід залишити дерево, коли стане зрозуміло, що програма працює і без нього, але дуже довго.

### Матричні перетворення
В цій роботі ви працюєте фактично із простою сценою, що складається з трьох об'єктів:
1. 

### Примітки
- В цій роботі від вас не вимагається параметризувати позицію.
- Для того щоб здати роботу потрібно зібрати реліз програми під win64 платформу та прикріпити у релізи у вашому гітхаб-репозиторії. Після цього потрібно оновити інформацію для своєї команди в [таблиці (вільний доступ)](https://docs.google.com/spreadsheets/d/1SvkJxrngMhUiRzwHw9N4DJ7HDHBRt_0DSU9-smrAaIk/edit?usp=sharing) та чекати результатів перевірки роботи.


### Оцінювання:
Максимум за роботу можна отримати _16 балів_. Мінімальний "набір" балів (9) можна отримати за роботу "гарний код + bmp + ppm". Якщо ваша ціль за підсумками семестру - Е, можете сміливо брати такий варіант. PNG\GIF трохи складніші та дозволяють отримати більше балів, ну those-who-dare варіант з JPEG дозволяє отримати бали з запасом.
- Якість написання коду - _3 бали_. Якщо ви здаєте роботу вчасно і отримуєте не максимум з цього пункту, ви можете доробити\порефакторити роботу і підвищити оцінку;
- Алгоритм PPM - _3 бали_;
- Алгоритм BMP - _3 балів_;
- Алгоритм PNG та GIF (з використанням бібліотеки для стиснення) - _4 бали_ . Додатково _+1 бал_ за самостоійну реалізацію
- Алгоритм JPEG - _8 балів_;

