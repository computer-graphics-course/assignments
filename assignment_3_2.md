###### Практична робота №3.2
## Рендеринг сцени II — робота зі створеним форматом [Draft]

В цій практичній роботі вам необхідно реалізувати рендерер, що вміє працювати із файлами створеного [формату](https://computer-graphics-course.github.io/scene-format/). Цього разу завдання складається з основної та додаткових частин, реалізувавши які можна отримати більше балів.

Пам'ятайте: краще мало функцій з притомною архітектурою, ніж багато функцій, в яких неможливо щось додати/змінити/зрозуміти.


### Що має вміти рендерер?
#### 1. Працювати із створеним форматом сцени
За [посиланнням](https://computer-graphics-course.github.io/scene-format/) — детальний опис формату, із вказанням обов'язкових і необов'язкових частин. Передусім ваше завдання — адаптувати структури даних, які зчитуються з файлів, до ваших власних. Постарайтесь утриматися від перероблювання власної архітектури під цю специфікацію: 

- по-перше, формат може (і скоріш за все буде) змінюватися, а вам би не хотілося щоразу змінювати значну частину коду для підтримки нових версій; 
- по-друге, ваші можливості впливати на формат обмежені, на відміну від можливості змінювати архітектуру, власні структури даних, алгоритми тощо; 
- по-третє, зважайте на ймовірність того, що з'явиться необхідність підтримувати інші формати (хоч в цьому курсі це і малоймовірно)

Робота з цим форматом групова — не тому що ви виконуєте роботу в командах, а тому що наразі версія специфікації не остаточна і формат вимагатиме змін, які будуть пропонувати і узгоджувати відразу декілька команд. При спробі реалізувати всі вимоги цієї роботи у кожної команди виникатимуть труднощі із роботою зі специфікацією або пропозиції щодо її змін. Будь ласка, проводьте обговорення/узгодження формату безпосередньо в репозиторії (за [посиланням](https://github.com/computer-graphics-course/scene-format)).

#### Підтримувати інтерполяцію нормалей

Ваша програма має підтримувати зчитування нормалей для кожної точки з obj-файлів і використовувати їх для обчислення нормалей при перетині променів з трикутниками. Для інтерполяції використовуються барицентричні координати точки перетину променя і трикутника.

#### Підтримувати кілька матеріалів

Щонайменше ваша програма має працювати із дзеркальними _(specular reflection model)_ та матовими _(lambertian reflection model)_ матеріалами. У кожного матеріалу можуть бути задані певні властивості, наприклад колір або коефіцієнт заломлення.

Набагато простіше виконати наступні завдання, якщо перед обчисленнями ви перетворите промені із світової системи координат в локальну систему, в якій точка перетину променя з об'єктом знаходиться в точці (0;0;0) і нормаль направлена завжди вгору.

Необов'язково. Ви можете додати кілька інших матеріалів. Серед них:

- Прозорий матеріал _(specular transmission)_. Матеріал пропускає промені через власну поверхню, заломлюючи їх відповідно до коефіцієнта заломлення. [Snell's law](https://en.wikipedia.org/wiki/Snell%27s_law). 
- Більш реалістичний прозорий матеріал: він має віддзеркалювати та заломлювати промені одночасно пропорційно до [формул Френеля](https://en.wikipedia.org/wiki/Fresnel_equations). [Specular_Reflection_and_Transmission](https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission)
- Модель Орена-Найара _(Oren–Nayar reflectance model)_. Разом із кольором має ще один параметр: нерівність поверхні _(roughness)_

Необов'язково. Ваша програма має підтримувати матеріали зі змішаними моделями відбиття. Наприклад, уявіть більярдний шар: він має рівномірний колір, тобто розсіює у всі сторони фотони з певною енергією (не зовсім за моделлю Ламберта, проте для простоти можна використати її), але його поверхня вкрита лаком, який відбиває частину всіх фотонів як дзеркало. Ви можете створювати матеріали, які будуть будуватися на кількох (або одній) BRDF і вибирати одну з них при трасуванні променя випадковим чином.

#### Підтримувати не тільки ray casting, а й Whitted ray tracing

На відміну від більш простої 2-ї роботи (той алгоритм прийнято називати _ray casting_), вам треба для кожного пікселя вихідного зображення трасувати більше ніж два промені. Детально алгоритм трасування описаний в [цій статті](https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-overview/light-transport-ray-tracing-whitted). Ви можете обрати будь який варіант, що вам сподобається, або реалізувати кілька:

- трасувати вторинні промені лише від дзеркальних _(specular)_, а не матових _(diffuse)_ поверхонь
- трасувати вторинні промені від усіх поверхонь (не забудьте обмежити глибину дерева)
- трасувати декілька вторинних променів від матових поверхонь, і лише один від дзеркальної. Після цього брати середнє значення отриманої яскравості _(radiance)_ для кожної точки на поверхні матеріалу.
- трасувати одразу кілька вторинних променів для змішаних матеріалів (наприклад, один для віддзеркаленого променя, другий для заломленого)
- трасувати завжди лише один вторинний промінь для кожного матеріалу з певною ймовірністю (наприклад, із ймовірністю 50% трасувати віддзеркалений промінь, і з 50% заломлений). При цьому можна трасувати одразу багато первинних променів із камери,а потім брати середнє значення із отриманої яскравості. Так можна обмежити ширину дерева трасування до 1. Такий підхід лежить в основі алгоритмів Монте-Карло.

Також варто залишити попередні алгоритми, щоб завжди мати змогу переконатися, що ви нічого не зламали. Слід забезпечити простий спосіб заміни нових алгоритмів на старі.

#### 2. Підтримувати рендеринг одразу декількох obj-файлів та примітивів

Тут все просто, ваша програма має вміти працювати не тільки з набором трикутників, а й з окремими об'єктами: сферою, диском та площиною. Кожен примітив, як і набір трикутників і з файлу (mesh), має певне положення у просторі та матеріал. 

Зауважте, що в кожному obj файлі може бути декілька mesh-ів, кожен зі своїм матеріалом.

#### Підтримувати кілька різних джерел світла



#### Підтримувати рендеринг із більш реалістичною камерою



#### Як здати роботу?
1. Реалізувати рендерер, звичним шляхом прикріпити реліз до репозиторію
2. Створити\знайти сцену, що буде містити максимальну кількість реалізованих вами елементів
3. Прикріпити отримані рендери до Readme вашого репозиторію
